{"version":3,"sources":["components/Button.js","services/Anki.js","data/deck_ids.js","data/models.js","scripts/logResult.js","scripts/correctDecks.js","scripts/changeSubs.js","components/ConsoleView.js","apps/CardFunctions.js","serviceWorker.js","index.js"],"names":["Button","_ref","onClick","text","react_default","a","createElement","Anki","url","request","action","params","axios","post","version","then","res","data","result","findNotes","searchString","query","notesInfo","noteIds","notes","addNotes","notesArray","deleteNotes","findCards","cardsInfo","cardIds","cards","changeDecks","newDeck","deck","DECK_IDS","subs","listening","other","MODELS","japanese","logResult","consoleDiv","document","getElementById","_len","arguments","length","output","Array","_key","innerHTML","join","map","content","console","log","searchTerms","moveDecks","concat","correctDeck","jisho","jishoApi","changeSubs","newNotes","forEach","note","searchForPhrase","fields","Note","value","jishoRes","newTags","tags","filter","tag","reading","word","meaning","senses","sense","english_definitions","newNote","deckName","modelName","Vocabulary","Vocabulary-Reading","Meaning","Sentence-1","Sentence","Sentence-1-Reading","Sentence-1-English","English","Sentence-1-Audio","Audio","Sentence-1-Image","Image","push","correctDecks","catch","err","ConsoleView","id","CardFunctions","style","marginBottom","components_Button","src_components_ConsoleView","Boolean","window","location","hostname","match","ReactDOM","render","apps_CardFunctions","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.53d82b02.chunk.js","sourcesContent":["import React from 'react';\n\nconst Button = ({ onClick, text }) => {\n    return (\n        <button onClick={onClick}>\n            {text}\n        </button>\n    )\n}\n\nexport default Button;","import axios from 'axios'\n\nconst Anki = {\n    // The standard AnkiConnect url\n    url: 'http://127.0.0.1:8765',\n\n    // Basic AnkiConnect call boilerplate\n    request: (action, params) => {\n        return axios\n            .post(Anki.url, {\n                \"action\": action,\n                \"version\": 6,\n                \"params\": params\n            })\n            .then(res => res.data.result);\n    },\n\n    // Searches for notes\n    // Takes in a search string \n    // Returns array of note ids\n    findNotes: (searchString) => {\n        return Anki.request(\"findNotes\", {\n            \"query\": searchString\n        });\n    },\n\n    // Get note informations\n    // Takes in an array of Note IDs\n    // Returns an array of note objects\n    notesInfo: (noteIds) => {\n        return Anki.request(\"notesInfo\", {\n            \"notes\": noteIds\n        })\n    },\n\n    // Adds new notes to Anki\n    // Takes in an array of notes\n    addNotes: (notesArray) => {\n        return Anki.request(\"addNotes\", {\n            \"notes\": notesArray\n        })\n    },\n\n    // Deletes notes from Anki\n    // Takes in an array of Note IDs\n    deleteNotes: (noteIds) => {\n        return Anki.request(\"deleteNotes\", {\n            \"notes\": noteIds\n        })\n    },\n\n    // Searches for cards\n    // Takes in a search string \n    // Returns array of note ids\n    findCards: (searchString) => {\n        return Anki.request(\"findCards\", {\n            \"query\": searchString\n        })\n    },\n\n    // Get card informations\n    // Takes in an array of card IDs\n    // Returns an array of card objects\n    cardsInfo: (cardIds) => {\n        return Anki.request(\"cardsInfo\", {\n            \"cards\": cardIds\n        })\n    },\n\n    // Move cards to a new deck\n    // Takes in an array of card IDs and the name of the new deck\n    changeDecks: (cardIds, newDeck) => {\n        return Anki.request(\"changeDeck\", {\n            \"cards\": cardIds,\n            \"deck\": newDeck\n        })\n    }\n}\n\nexport default Anki;","const DECK_IDS = {\n    subs: \"01 - 日本語::01 - カード::03 - subs_bank\",\n    listening: \"01 - 日本語::01 - カード::01 - Listening\", \n    other: \"01 - 日本語::01 - カード::02 - Other\"\n}\n\nexport default DECK_IDS;\n","const MODELS = {\n    japanese: \"Japanese\"\n}\n\nexport default MODELS;","// Runs two functions\n// 1) prints ...ouput onto a fake on page console view\n// 2) Dummy wrapper around real console.log call\n// In the future, it will also be externalized\nconst logResult = (...output) => {\n    const consoleDiv = document.getElementById('console-text');\n    consoleDiv.innerHTML += output.join('<br />') + '<br />';\n\n    output.map(content => console.log(content))\n}\n\nexport default logResult;","import Anki from '../services/Anki';\nimport DECK_IDS from '../data/deck_ids';\n\nimport logResult from '../scripts/logResult';\n\nconst searchTerms = {\n    toListening: '\"note:Japanese\" (card:3 OR card:4 or card:5 OR card:6 or card:7 or card:8 or card:9) -deck:\"* Listening\"',\n    toOther: '\"note:Japanese\" (card:1 OR card:2) -deck:\"*Other\"'\n}\n\nconst moveDecks = (searchString, newDeck) => {\n    Anki\n        .findCards(searchString)\n        .then(res => {\n            logResult(\n                `found ${res.length} cards to move to ${newDeck}`,\n                'moving...'\n            );\n\n            Anki\n                .changeDecks(res, newDeck)\n                .then(res => {\n                    logResult(`cards moved`);\n                })\n        })\n}\n\nconst correctDeck = () => {\n    logResult('searching for misplaced cards...');\n\n    moveDecks(searchTerms.toListening, DECK_IDS.listening);\n    moveDecks(searchTerms.toOther, DECK_IDS.other);\n}\n\nexport default correctDeck;","// This script runs through your saved decks and searches for subs2srs cards tagged as '00change' then\n// creates new standard Japanese cards and autofills the information. It then moves these cards to their\n// proper decks (listening or not) thru an external script and deletes the original subs2srs cards\n\nimport Anki from '../services/Anki';\nimport DECK_IDS from '../data/deck_ids';\nimport MODELS from '../data/models';\nimport jishoApi from 'unofficial-jisho-api';\n\nimport logResult from '../scripts/logResult';\nimport correctDecks from '../scripts/correctDecks';\n\nconst jisho = new jishoApi();\n\n// const dummyNotes = [{\n//     \"deckName\": DECK_IDS.subs,\n//     \"modelName\": MODELS.japanese,\n//     \"fields\": {\n//         \"Vocabulary\": 'test',\n//         \"Vocabulary-Reading\": 'test',\n//         \"Meaning\": 'test',\n//         \"Sentence-1\": 'test',\n//         \"Sentence-1-Reading\": 'test',\n//         \"Sentence-1-English\": 'test',\n//         \"Sentence-1-Audio\": '',\n//         \"Sentence-1-Image\": ''\n//     },\n//     tags: ['00change', 'marked']\n// }]\n\nconst changeSubs = () => {\n    logResult('running function...');\n\n    logResult('gathering notes...');\n    Anki\n        // searches Anki for all new cards tagged 00change\n        .findNotes('tag:00change is:new')\n        // save the found notes to nodeIds array\n        .then(res => {\n            const noteIds = res;\n            if(noteIds.length === 0) {\n                logResult('no notes found', 'ending function', '');\n                return;\n            }\n            logResult(`${noteIds.length} notes gathered`, 'pulling notes information...');\n\n            // searches Anki for the notes info then adds new notes with the proper values\n            Anki\n            .notesInfo(noteIds)\n            .then(res => {\n                logResult('information pulled', 'creating new notes...')\n\n                const newNotes = [];\n\n                res.forEach(note => {\n                    jisho \n                        .searchForPhrase(note.fields.Note.value)\n                        .then(res => {\n                            const jishoRes = res.data[0];\n\n                            // Create a new array for tags w/o the 00change/01change tag\n                            const newTags = note.tags.filter(tag => tag !== '00change' && tag!== '01change');\n\n                            // Adds a reading if one exists\n                            const reading = jishoRes.japanese[0].word \n                                ? `${note.fields.Note.value}[${jishoRes.japanese[0].reading}]` \n                                : '';\n                            \n                            // Turns the defintion array into a string\n                            // Get an array of strings for each sub-definition\n                            const subdefs = res.data[0].senses.map((sense) => {\n                                return sense.english_definitions.join(', ');\n                            })\n\n                            // Join the sub-definitions into one long string\n                            const meaning = subdefs.join('; ');\n\n                            const newNote = {\n                                \"deckName\": DECK_IDS.subs,\n                                \"modelName\": MODELS.japanese,\n                                \"fields\": {\n                                    \"Vocabulary\": note.fields.Note.value,\n                                    \"Vocabulary-Reading\": reading,\n                                    \"Meaning\": meaning,\n                                    \"Sentence-1\": note.fields.Sentence.value,\n                                    \"Sentence-1-Reading\": note.fields[\"Sentence-Reading\"].value,\n                                    \"Sentence-1-English\": note.fields.English.value,\n                                    \"Sentence-1-Audio\": note.fields.Audio.value,\n                                    \"Sentence-1-Image\": note.fields.Image.value\n                                },\n                                tags: newTags\n                            }\n\n                            logResult(\n                                '...',\n                                `new note`,\n                                `term: ${newNote.fields.Vocabulary}`,\n                                `meaning: ${newNote.fields.Meaning}`,\n                                `sentence: ${newNote.fields['Sentence-1']}`,\n                                `english: ${newNote.fields['Sentence-1-English']}`,\n                                `tags: ${newNote.tags.join(', ')}`\n                            )\n\n                            newNotes.push(newNote);\n                        }).then((res) => {\n                            // test if this is last time function is run by testing if the new notes array \n                            // is as long as the array of note IDs \n                            if(newNotes.length === noteIds.length) {\n                                logResult(\n                                    '...',\n                                    `created ${newNotes.length} new notes`,\n                                    'sending to Anki...'\n                                )\n\n                                // Add the new notes to Anki\n                                Anki\n                                .addNotes(newNotes)\n                                .then(res => {\n                                    logResult(\n                                        `${res.length} notes added`\n                                    )\n\n                                    // run the deck fixing function here\n                                    correctDecks();\n\n                                    // Deltes the old notes\n                                    logResult('deleting old notes...');\n                                    Anki\n                                        .deleteNotes(noteIds)\n                                        .then(res => {\n                                            logResult(`${noteIds.length} notes deleted`)\n                                        })\n                                })\n                            }\n                        }).catch(err => logResult(err))\n                })\n            })\n        })       \n}\n\nexport default changeSubs;","import React from 'react';\n\nimport '../components/ConsoleView.css';\n\nconst ConsoleView = () => {\n    return (\n        <div id=\"console-view\">\n            <p id=\"console-text\">\n\n            </p>\n        </div>\n    )\n}\n\nexport default ConsoleView;","import React from 'react';\n\nimport '../App.css';\n\nimport Button from '../components/Button';\nimport changeSubs from '../scripts/changeSubs';\nimport correctDecks from '../scripts/correctDecks';\nimport ConsoleView from '../components/ConsoleView';\n\nconst CardFunctions = () => {\n    return (\n        <div id=\"functions-view\">\n            <p style={{marginBottom:0}}>Scripts</p>\n            <Button onClick={() => changeSubs()} text=\"00change\" />\n            <Button onClick={() => correctDecks()} text=\"correct decks\" />\n\n            <ConsoleView />\n         </div>\n    )\n}\n\nexport default CardFunctions;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n// import SentenceFinder from './apps/SentenceFinder';\nimport CardFunctions from './apps/CardFunctions';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<CardFunctions />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}